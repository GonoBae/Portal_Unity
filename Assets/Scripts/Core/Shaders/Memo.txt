1. 오브젝트 데이터 받아오기
 - 그래픽 카드는 Vertex로 이루어진 물체의 데이터 값을 받아온다.
 - Vertex는 인덱스 넘버, 포지션, 노멀, 컬러 등의 정보를 가지고 있다.
 - 그래픽 카드는 정보들을 이용해 버텍스들을 잇고, 삼각형 면을 생성.

2. 정점 쉐이더 (Vertex Shader) => 그려질 위치를 결정
 - 각 정점의 공간을 변환하는 것.
 - 3D 물체를 구성하는 정점의 수만큼 실행.
  1) 로컬 좌표계 상태
  -> 자신(0, 0, 0)의 위치값을 가짐, 피벗이 원점
  -> 모든 정점의 위치는 피벗에서 얼마나 떨어져있냐로 결정
  2) 월드 좌표계 상태 = 로컬 좌표계 * 모델행렬
  -> 월드 중심(0, 0, 0)을 기준으로 얼마나 떨어져있는가를 표현.
  3) 카메라 좌표계 상태 = 월드 좌표계 * 뷰 행렬
  -> 카메라 중심(0, 0, 0)을 기준으로 얼마나 떨어져있는가를 표현.
  -> 같은 위치에 있어도 카메라의 위치에 따라 다르게 보임.
  -> 매번 카메라의 위치와 회전을 고려하는 것보다, 카메라는 원점에 두고 오브젝트를 상대적으로 배치하는게 간결.
  4) 클립 공간(카메라가 보는 영역) = 카메라 좌표계 * 투영행렬
  -> 원근감을 부여. 먼 곳은 좁혀진 것처럼 버텍스 위치 조정.

  * 카메라 공간 : 카메라 위치를 원점으로 삼은 공간 -> 시야와 원근감 없음
  * 클립 공간 : 카메라의 시점을 반영한 공간 -> 시야와 원근감이 존재

  '오브젝트 공간'에서 '클립 공간'으로 변환

3. 레스터라이져
 - 3D 오브젝트가 2D 모니터에 보이도록 픽셀이 됨.
 - 레스터라이져는 하드웨어 장치.

 -> 3D 오브젝트가 2D 모니터 상에서 어디 픽셀에 찍힐지를 계산.
 -> 픽셀 수만큼 실행. (화면 해상도만큼)
 -> 버텍스 셰이더로부터 전달받은 정점들에 삼각형을 구상하고 채워줘서 '프레그먼트 셰이더'로 전달

 프레그먼트 : 픽셀후보 (앞 뒤로 배치된 물체에서 가려진 물체는 최종 픽셀로 사용되지 않음.)
 클립 공간 -> 스크린 공간
  - 정규화된 공간에서 스크린에 맞춘 공간으로 변형.
  - x, y => 스크린의 가로, 세로 / z => 누가 앞에 그려지는지 판단

4. 픽셀 쉐이더 / 프레그먼트 쉐이더 => 칠할 색을 결정
 : 전달받은 프레그먼트에 어떤 색을 채울지 결정하는 단계, 레스터라이져가 전달한 프레그먼트 수만큼 실행
 - 모니터가지 넘어온 3D 그래픽 데이터가 본격적으로 픽셀로 찍힘.
 - 이 픽셀은 파란색, 이 픽셀은 그림자를 받으니 좀 더 진한 파란색 -> 이렇게



 오브젝트가 화면에서 차지하고 있는 모든 픽셀마다 실행되는 프로그램.
 각 픽셀의 컬러를 계산하고 출력.